/////////////////////////////////////////////////////////////////////////
  MASTER TODOLIST   MASTER TODOLIST MASTER TODOLIST     MASTER TODOLIST
/////////////////////////////////////////////////////////////////////////


TODO
erstmal nur als Scriptsprache(keine Tababstände), die Logik kann dann nachher easy
ins OOP übertragen werden
[+]	- Logik von Nodes zum Interpreter schieben
[+]	- booleansche Logik &, &&, |, || implementieren
[+]	- verkettung von conditions
[+] - conditions klammern
[+] - variablen
[+]	- Die *Build Klassen in den Parser einbauen
[+] - ++x, x++ Operand (Increment)
[+] - --x, x-- Operand (Decrement)
[+]	- += Operand
[+]	- -= Operand
[+]	- *= Operand
[+]	- /= Operand
[+]	- %= Operand
[+]	- while
[+] - do-while
[+]	- for
[+]	- *in for-loop initialisierte var ist im falschen scope!!*
[+]	- *ALLE KEYWORDS IN EIGENE TOKENS*
[]  - alle primitiven (siehe syntax.txt)
[]	- arrays -> ArrayNode
[]	- foreach
[]	- ?Preprocessor?
[]	- Nutzerfunktionen
[]	- Parameter
[] 	- Rueckgabewerte
[]	- Ein paar builIn Funktionen
[]  - string als char[]
*CLEANUP / REFACTORING*
[+]  - curToken.value.equals(value) -> curToken.compare(value)
[+]  - +=, -=, *=, /=  sollen zu normalen assignNode geparsed werden    (x+= 1 * 2 -> x = x + (1 * 2) )
[]  - increment/decrement sind schlecht implementiert
[+]  - Dateiendung in .#s aendern
PRIMTIVE DATENTYPEN:
	- Bei der Initialisierung/Deklarierung muss implizit geschaut werden, ob die rückgabewerte
	  mit dem Primitiven übereinstimmen
	  Beispiel: i = 0.5 	#falsch
				i = 1 / 2 	#korrekt -> Ergebnis ist aber natuerlich abgeschnitten


TODO
 -	Strings als erste Klasse
 - Formatierte Strings   f("Das {} ist {}",fahrzeug,farbe)
 -  Bitwise operationen einfuegen -> Lexer aktualisieren ( & | ^ ~ << >> )
       * The & (bitwise AND) The result of AND is 1 if both of the two bits are 1.
       * The | (bitwise OR)  The result of OR is 1 if any of the two bits is 1.
       * The ^ (bitwise XOR) The result of XOR is 1 if the two bits are different.
       * The ~ (bitwise NOT) all bits are swapped
       * The << (left shift) takes two numbers, left shifts the bits of the first operand, the second operand decides the number of places to shift.
       * The >> (right shift) takes two numbers, right shifts the bits of the first operand, the second operand decides the number of places to shift.
    Je nachdem worin das Ergebnis gespeichert werden soll, wird entweder bitwise oder boolean algebra angewandt.
 - ? Wie werden Pointer funktionieren, denn '*' überschneidet sich mit dem static access modifier ? 
 - Das erzeugen von Objekten soll m�glich sein
 - Objekte sollen als Parameter/R�ckgabewert m�glich sein -> evtl. Data �berarbeiten ?
 - Enums
 - Interfaces
 - Vererbung
 - Casting
 - access modifier hinzufuegen
    * public +
    * private -
    * static *
    * (protected?) /
    * moegliche Zeichen:  � $ % & ? ~ _ . , : ; < > |
    Werden dann im Symboltable eingetragen. Wenn die get() Methode aufgerufen wird, m�ssen einfach nur neue
    Regelungen basierend auf dem AccessModifier der gesuchten Variable erkl�rt werden.
 - lexer.txt, log.txt zu .log aendern und in eigenem /log Ordner aufbewahren
 - ? Betragsstriche |a|?
 - ?skalar (a|a) ?
 - Überschreiben von Rechenoperationen für Objekte
 - Testen, ob bitwise &,| wirklich funktionieren
[-] - ?MOD operator zu Token.isOP() hinzufuegen?
int a = 2² + |test()| * (a|a)
int a = pow(2,2) + abs(test()) * (a*a)
