/////////////////////////////////////////////////////////////////////////
  MASTER TODOLIST   MASTER TODOLIST MASTER TODOLIST     MASTER TODOLIST
/////////////////////////////////////////////////////////////////////////


TODO
erstmal nur als Scriptsprache(keine Tababstände), die Logik kann dann nachher easy
ins OOP übertragen werden
[+]	- Logik von Nodes zum Interpreter schieben
[+]	- booleansche Logik &, &&, |, || implementieren
[+]	- verkettung von conditions
[+] - conditions klammern
[+] - variablen
[+]	- Die *Build Klassen in den Parser einbauen
[+] - ++x, x++ Operand (Increment)
[+] - --x, x-- Operand (Decrement)
[+]	- += operand
[+]	- -= Operand
[+]	- *= Operand
[+]	- /= Operand
[+]	- %= Operand
[+]	- while
[+] - do-while
[+]	- for
[+]	- *in for-loop initialisierte var ist im falschen scope!!*
[+]	- *ALLE KEYWORDS IN EIGENE TOKENS*
[+] - statische variablentypen	
[+] - automatic type-conversion
[+] - type-conversion with loss (int a = 1 / 2 -> a = 0)
[+] - alle primitiven zahlentypen
[+] - +=, -=, *=, /=  sollen zu normalen assignNode geparsed werden    (x+= 1 * 2 -> x = x + (1 * 2) )
[+] - Dateiendung in .#s aendern
[+] - curToken.value.equals(value) -> curToken.compare(value)
[+] - manche TokenTypes umbenennen (ADD -> PLUS)
[+] - instanceof durch NodeType(enum) ersetzen   	*140ms für parser*
[+] - MOD operator zu Token.isOP() hinzufuegen
[+] - schleifen erzeugen i Scopes im SymbolTable (stattdessen SymbolTable des scopes clearen un reusen)
[+] - schauen, warum Parser so langsam ist
[+] - ?EqualAssignNode redundant, einfach AssignNode benutzen?
[+] - Pointer 
[]  - ++, -- operatoren sind schlecht implementiert
[]	- arrays -> ArrayNode
[]	- foreach
[]	- ?Preprocessor?
[]	- Nutzerfunktionen
[]	- Parameter
[] 	- Rueckgabewerte
[]	- Ein paar builIn Funktionen
[]  - char
[]  - string als char[]
[]  - BUG man kann pointer und rechungen mischen (int a = &a + 2 * 3)
[]  - Casting int()


TODO
 - Strings als erste Klasse
 - Formatierte Strings   f("Das {} ist {}F",fahrzeug,farbe)
 Bitwise operationen einfuegen -> Lexer aktualisieren ( & | ^ ~ << >> ):
[+] - & (bitwise AND) The result of AND is 1 if both of the two bits are 1.
[+] - | (bitwise OR)  The result of OR is 1 if any of the two bits is 1.
[] - ^ (bitwise XOR) The result of XOR is 1 if the two bits are different.
[] - ~ (bitwise NOT) all bits are swapped
[] - << (left shift) takes two numbers, left shifts the bits of the first operand, the second operand decides the number of places to shift.
[] - >> (right shift) takes two numbers, right shifts the bits of the first operand, the second operand decides the number of places to shift.
- Testen, ob bitwise &,| wirklich funktionieren

- Das erzeugen von Objekten soll moeglich sein
 - Objekte sollen als Parameter/R�ckgabewert m�glich sein -> evtl. Data �berarbeiten ?
 - Enums
 - Interfaces
 - Vererbung
 - access modifier hinzufuegen
    * public +
    * private -
    * static *
    * (protected?) /
	* read r
	* write w
    * moegliche Zeichen:  � $ % & ? ~ _ . , : ; < > |
    Werden dann im Symboltable eingetragen. Wenn die get() Methode aufgerufen wird, m�ssen einfach nur neue
    Regelungen basierend auf dem AccessModifier der gesuchten Variable erkl�rt werden.
 - ? Betragsstriche |a|?
 - Überschreiben von Rechenoperationen für Objekte
int a = 2² + |test()| * (a|a)
int a = pow(2,2) + abs(test()) * (a*a)
[-] - The datetime calculation on the Log class is fucking slow
*!NEUE SYNTAX?*:

MatLab hat sehr schöne Syntax zum erzeugen von arrays und generell iterativen Strukturen

	for (int x = 0:arr.len-1:1):
		#code

	for (int x = 0, x <= 10, x++):
		#code
	
	int x (0:10:1):
		#code


Momentaner Ablauf:

Interpretieren:	
1. Lexer
2. Parser
3. Interpreter -> ConversionChecking

Compilen (noch nicht eingefuegt):
1. Lexer
2. Parser			  (Syntax)
3. ConversionChecking (Semantic)
4. AST Optimizer
5. ByteCode Generator
6. ByteCode Optimizer

!!! 2 Optimizer sinnvoll?