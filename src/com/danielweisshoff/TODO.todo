/////////////////////////////////////////////////////////////////////////
  MASTER TODOLIST   MASTER TODOLIST MASTER TODOLIST     MASTER TODOLIST
/////////////////////////////////////////////////////////////////////////

TODO
- parser nach grammar.txt umbauen
Jede production bekommt eine eigene Klasse. Im Parser wird die Syntax der productions
gecheckt und falls korrekt, die passende Klasse der Production erzeugt.
Die Klassen der Productions enthalten alle für sie wichtigen infos.
Bsp.
IfNode speichert einen boolean und ein statement

- ++ und -- erstmals entfernen
TODO
erstmal nur als Scriptsprache(keine Tababstände), die Logik kann dann nachher easy
ins OOP übertragen werden
[+]	- Logik von Nodes zum Interpreter schieben
[+]	- booleansche Logik &, &&, |, || implementieren
[+]	- verkettung von conditions
[+] - conditions klammern
[+] - variablen
[+]	- Die *Build Klassen in den Parser einbauen
[+]	- += operand
[+]	- -= Operand
[+]	- *= Operand
[+]	- /= Operand
[+]	- %= Operand
[+]	- while
[+] - do-while
[+]	- for
[+]	- *in for-loop initialisierte var ist im falschen scope!!*
[+]	- *ALLE KEYWORDS IN EIGENE TOKENS*
[+] - statische variablentypen	
[+] - automatic type-conversion
[+] - type-conversion with loss (int a = 1 / 2 -> a = 0)
[+] - alle primitiven zahlentypen
[+] - +=, -=, *=, /=  sollen zu normalen assignNode geparsed werden    (x+= 1 * 2 -> x = x + (1 * 2) )
[+] - Dateiendung in .#s aendern
[+] - curToken.value.equals(value) -> curToken.compare(value)
[+] - manche TokenTypes umbenennen (ADD -> PLUS)
[+] - instanceof durch NodeType(enum) ersetzen   	*140ms für parser*
[+] - MOD operator zu Token.isOP() hinzufuegen
[+] - schleifen erzeugen i Scopes im SymbolTable (stattdessen SymbolTable des scopes clearen un reusen)
[+] - schauen, warum Parser so langsam ist
[+] - ?EqualAssignNode redundant, einfach AssignNode benutzen?
[+] - Pointer 
[-] - ++x, x++ Operand (Increment)
[-] - --x, x-- Operand (Decrement)
[-] - Errorchecking verbessern  
[-] - arrays -> ArrayNode
[-] - foreach
[-] - ?Preprocessor?
[-] - Nutzerfunktionen
[-] - Parameter
[-] - Rueckgabewerte
[-] - Ein paar builIn Funktionen
[-] - char
[-] - string als char[]
[-] - Casting int()
[-] - pointer arithmetic

TODO
 - Strings als erste Klasse
 - Formatierte Strings   f("Das {} ist {}F",fahrzeug,farbe)
 Bitwise operationen einfuegen -> Lexer aktualisieren ( & | ^ ~ << >> ):
[+] - & (bitwise AND) The result of AND is 1 if both of the two bits are 1.
[+] - | (bitwise OR)  The result of OR is 1 if any of the two bits is 1.
[] - ^ (bitwise XOR) The result of XOR is 1 if the two bits are different.
[] - ~ (bitwise NOT) all bits are swapped
[] - << (left shift) takes two numbers, left shifts the bits of the first operand, the second operand decides the number of places to shift.
[] - >> (right shift) takes two numbers, right shifts the bits of the first operand, the second operand decides the number of places to shift.
- Testen, ob bitwise &,| wirklich funktionieren

- Das erzeugen von Objekten soll moeglich sein
 - Objekte sollen als Parameter/R�ckgabewert m�glich sein -> evtl. Data �berarbeiten ?
 - Enums
 - Interfaces
 - Vererbung
 - access modifier hinzufuegen
    * public +
    * private -
    * static *
    * (protected?) /
	* read r
	* write w
    * moegliche Zeichen:  � $ % & ? ~ _ . , : ; < > |
    Werden dann im Symboltable eingetragen. Wenn die get() Methode aufgerufen wird, m�ssen einfach nur neue
    Regelungen basierend auf dem AccessModifier der gesuchten Variable erkl�rt werden.
 - ? Betragsstriche |a|?
 - Überschreiben von Rechenoperationen für Objekte
int a = 2² + |test()| * (a|a)
int a = pow(2,2) + abs(test()) * (a*a)
[-] - The datetime calculation on the Log class is fucking slow
*!NEUE SYNTAX?*:

MatLab hat sehr schöne Syntax zum erzeugen von arrays und generell iterativen Strukturen

	for (int x = 0:arr.len-1:1):
		#code

	for (int x = 0, x <= 10, x++):
		#code
	
	int x (0:<10:1):
		#code


Momentaner Ablauf:

Interpretieren:	
1. Lexer
2. Parser
3. Interpreter + Symboltable -> ConversionChecking

Compilen (noch nicht eingefuegt):
1. Lexer
2. Parser			  (Syntax) + Symboltable
3. ConversionChecking (Semantic)
4. AST Optimizer
5. ByteCode Generator
6. ByteCode Optimizer

!!! 2 Optimizer sinnvoll?


int i = 10
if (i < 11):
	int x = i * i
	out i


i
i
	x i i
	i


stumpfes eintragen in hashmap
i
	x
	i